const express = require('express');
const puppeteer = require('puppeteer');
const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const cors = require('cors');

const app = express();
app.use(express.json({ limit: '200mb' }));
app.use(cors());

const PORT = 3001;

// Helper to run shell commands
const runCmd = (cmd) => new Promise((resolve, reject) => {
    exec(cmd, (error, stdout, stderr) => {
        if (error) {
            console.error(`Cmd Error: ${cmd}`, stderr);
            reject(error);
        } else resolve(stdout);
    });
});

app.post('/render', async (req, res) => {
    const { slides, projectName } = req.body;
    
    const jobId = `job_${Date.now()}`;
    const workDir = path.join(__dirname, 'temp', jobId);
    const framesDir = path.join(workDir, 'frames');
    const audioDir = path.join(workDir, 'audio');
    const segmentsDir = path.join(workDir, 'segments');
    const outputVideo = path.join(workDir, 'output.mp4');
    const fileListPath = path.join(workDir, 'files.txt');

    console.log(`[${jobId}] Starting render for ${slides.length} slides...`);

    try {
        await fs.ensureDir(framesDir);
        await fs.ensureDir(audioDir);
        await fs.ensureDir(segmentsDir);

        // --- STEP 1: Capture Slides with Puppeteer ---
        const browser = await puppeteer.launch({
            args: [
                '--no-sandbox', 
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage', // Critical for VPS memory
                '--disable-accelerated-2d-canvas',
                '--disable-gpu'
            ]
        });
        
        const page = await browser.newPage();
        await page.setViewport({ width: 1920, height: 1080 });
        
        // GLOBAL TIMEOUT: 10 Minutes (600000ms)
        page.setDefaultNavigationTimeout(600000); 
        page.setDefaultTimeout(600000);

        const videoSegments = [];

        for (let i = 0; i < slides.length; i++) {
            const slide = slides[i];
            const slideId = String(i).padStart(3, '0');
            const framePath = path.join(framesDir, `slide_${slideId}.png`);
            
            // 1. Render HTML to Image
            const htmlContent = `
                <!DOCTYPE html>
                <html>
                    <head>
                        <meta charset="UTF-8">
                        <script src="https://cdn.tailwindcss.com"></script>
                        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800;900&display=swap" rel="stylesheet">
                        <style>
                            body { margin: 0; padding: 0; width: 1920px; height: 1080px; overflow: hidden; font-family: 'Inter', sans-serif; background: white; }
                        </style>
                    </head>
                    <body>${slide.htmlContent || '<div></div>'}</body>
                </html>
            `;

            // CRITICAL FIX: timeout: 0 (Infinite wait) + networkidle2 (Less strict)
            await page.setContent(htmlContent, { 
                waitUntil: 'networkidle2', 
                timeout: 0 
            });
            
            await page.screenshot({ path: framePath, type: 'png' });

            // 2. Handle Audio
            let audioPath = null;
            let duration = 3; // Default duration

            if (slide.audioUrl) {
                const audioName = `audio_${slideId}.mp3`;
                audioPath = path.join(audioDir, audioName);
                
                if (slide.audioUrl.startsWith('data:')) {
                    const base64Data = slide.audioUrl.split(';base64,').pop();
                    await fs.writeFile(audioPath, base64Data, { encoding: 'base64' });
                } else if (slide.audioUrl.startsWith('http')) {
                    await runCmd(`curl -L -o "${audioPath}" "${slide.audioUrl}"`);
                }

                try {
                    const durStr = await runCmd(`ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${audioPath}"`);
                    duration = parseFloat(durStr) || 3;
                } catch (e) {
                    console.error(`Audio duration check failed for slide ${i}, using default.`);
                }
            }

            // 3. Create Video Segment
            const segmentPath = path.join(segmentsDir, `seg_${slideId}.mp4`);
            
            if (audioPath) {
                // Image + Audio
                const cmd = `ffmpeg -loop 1 -i "${framePath}" -i "${audioPath}" -c:v libx264 -tune stillimage -c:a aac -b:a 192k -pix_fmt yuv420p -shortest "${segmentPath}"`;
                await runCmd(cmd);
            } else {
                // Image + Silence
                const cmd = `ffmpeg -loop 1 -i "${framePath}" -f lavfi -i anullsrc -c:v libx264 -tune stillimage -c:a aac -t ${duration} -pix_fmt yuv420p "${segmentPath}"`;
                await runCmd(cmd);
            }

            videoSegments.push(`file '${segmentPath}'`);
        }

        await browser.close();

        // --- STEP 2: Concatenate ---
        await fs.writeFile(fileListPath, videoSegments.join('\n'));
        const concatCmd = `ffmpeg -f concat -safe 0 -i "${fileListPath}" -c copy "${outputVideo}"`;
        await runCmd(concatCmd);

        console.log(`[${jobId}] Render Complete!`);
        
        // --- STEP 3: Download ---
        res.download(outputVideo, `${projectName.replace(/\s+/g, '_')}.mp4`, (err) => {
             if(err) console.error(err);
             fs.remove(workDir).catch(() => {});
        });

    } catch (err) {
        console.error(`[${jobId}] Failed:`, err);
        res.status(500).json({ error: err.message });
        fs.remove(workDir).catch(() => {});
    }
});

app.listen(PORT, '0.0.0.0', () => console.log(`VSL Renderer running on port ${PORT}`));