const express = require('express');
const puppeteer = require('puppeteer');
const fs = require('fs-extra');
const path = require('path');
const { exec } = require('child_process');
const cors = require('cors');

const app = express();
app.use(express.json({ limit: '900mb' }));
app.use(cors());

const PORT = 3001;
const jobs = new Map();

app.use('/outputs', express.static(path.join(__dirname, 'outputs')));
fs.ensureDirSync(path.join(__dirname, 'outputs'));
fs.ensureDirSync(path.join(__dirname, 'temp'));

const runCmd = (cmd) => new Promise((resolve, reject) => {
    exec(cmd, (error, stdout, stderr) => {
        if (error) reject(error);
        else resolve(stdout);
    });
});

async function renderSlides(slides, framesDir, audioDir, updateJob) {
    const AUDIO_CONCURRENCY = 40; 
    const TAB_CONCURRENCY = 8;
    
    updateJob({ status: 'downloading_audio', progress: 5 });
    for (let i = 0; i < slides.length; i += AUDIO_CONCURRENCY) {
        const batch = slides.slice(i, i + AUDIO_CONCURRENCY);
        await Promise.all(batch.map(async (slide, idx) => {
            if (!slide.audioUrl) return;
            const id = i + idx;
            const dest = path.join(audioDir, `audio_${String(id).padStart(3, '0')}.mp3`);
            try {
                if (slide.audioUrl.startsWith('data:')) {
                    await fs.writeFile(dest, slide.audioUrl.split(',')[1], 'base64');
                } else {
                    await runCmd(`curl -s -k -L -o "${dest}" "${slide.audioUrl}"`);
                }
            } catch (e) {
                console.error(`Audio ${id} Download Failed:`, e.message);
            }
        }));
    }

    updateJob({ status: 'rendering_slides', progress: 15 });
    const BROWSER_BATCH = 30;
    for (let i = 0; i < slides.length; i += BROWSER_BATCH) {
        const chunk = slides.slice(i, i + BROWSER_BATCH);
        const browser = await puppeteer.launch({ 
            protocolTimeout: 300000,
            args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-gpu', '--disable-dev-shm-usage', '--window-size=1920,1080'] 
        });
        
        try {
            for (let j = 0; j < chunk.length; j += TAB_CONCURRENCY) {
                const tabs = chunk.slice(j, j + TAB_CONCURRENCY);
                await Promise.all(tabs.map(async (slide, tIdx) => {
                    const globalIdx = i + j + tIdx;
                    const id = String(globalIdx).padStart(3, '0');
                    const filePath = path.join(framesDir, `slide_${id}.png`);
                    
                    for (let attempt = 1; attempt <= 3; attempt++) {
                        const page = await browser.newPage();
                        try {
                            await page.setViewport({ width: 1920, height: 1080 });
                            const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"><script src="https://cdn.tailwindcss.com"></script><style>body{margin:0;padding:0;overflow:hidden;background:black;}</style></head><body>${slide.htmlContent}</body></html>`;
                            await page.setContent(html, { waitUntil: 'networkidle0', timeout: 45000 });
                            await new Promise(r => setTimeout(r, 500)); 
                            await page.screenshot({ path: filePath, timeout: 30000 });
                            if (await fs.pathExists(filePath)) break;
                        } catch (e) {
                            if (attempt === 3) throw new Error(`Slide ${id} failed`);
                        } finally {
                            await page.close();
                        }
                    }
                }));
                updateJob({ progress: 15 + Math.floor(((i + j) / slides.length) * 65) });
            }
        } finally { await browser.close(); }
    }
}

app.post(['/render', '/render-zip'], async (req, res) => {
    const isZip = req.path.includes('zip');
    const { slides, projectName } = req.body;
    const jobId = `job_${Date.now()}`;
    
    res.json({ jobId });

    const updateJob = (upd) => jobs.set(jobId, { ...jobs.get(jobId), ...upd });
    updateJob({ status: 'starting', progress: 0 });
    
    const workDir = path.join(__dirname, 'temp', jobId);
    try {
        const dirs = ['frames', 'audio', 'segments'].map(d => path.join(workDir, d));
        await Promise.all(dirs.map(d => fs.ensureDir(d)));

        await renderSlides(slides, dirs[0], dirs[1], updateJob);

        const safeProjectName = (projectName || 'export').replace(/[^\w\s]/gi, '').replace(/\s+/g, '_');
        const finalFilename = `${safeProjectName}_${jobId}.${isZip ? 'zip' : 'mp4'}`;
        const finalPath = path.join(__dirname, 'outputs', finalFilename);

        if (isZip) {
            updateJob({ status: 'zipping', progress: 95 });
            await runCmd(`cd "${workDir}" && zip -r -j -q "${finalPath}" frames audio`);
        } else {
            updateJob({ status: 'creating_video', progress: 85 });
            const FFMPEG_CONC = 12;
            for (let i = 0; i < slides.length; i += FFMPEG_CONC) {
                const batch = slides.slice(i, i + FFMPEG_CONC);
                await Promise.all(batch.map(async (_, idx) => {
                    const globalIdx = i + idx;
                    const id = String(globalIdx).padStart(3, '0');
                    const img = path.join(dirs[0], `slide_${id}.png`), aud = path.join(dirs[1], `audio_${id}.mp3`), out = path.join(dirs[2], `seg_${id}.mp4`);
                    
                    if (await fs.pathExists(aud)) {
                        // PERFECT SYNC COMMAND:
                        // -loop 1: Loop the image
                        // -r 30: Force 30fps
                        // -shortest: Stop exactly when the audio finishes
                        // -c:a aac: Standardize audio for perfect concatenating
                        await runCmd(`ffmpeg -y -loop 1 -r 30 -i "${img}" -i "${aud}" -c:v libx264 -preset ultrafast -tune stillimage -c:a aac -b:a 192k -pix_fmt yuv420p -shortest "${out}"`);
                    } else {
                        await runCmd(`ffmpeg -y -loop 1 -r 30 -i "${img}" -c:v libx264 -preset ultrafast -t 3 -pix_fmt yuv420p "${out}"`);
                    }
                }));
                updateJob({ progress: 85 + Math.floor((i / slides.length) * 10) });
            }
            const list = (await fs.readdir(dirs[2])).filter(f => f.endsWith('.mp4')).sort().map(f => `file 'segments/${f}'`).join('\n');
            await fs.writeFile(path.join(workDir, 'list.txt'), list);
            await runCmd(`cd "${workDir}" && ffmpeg -y -f concat -safe 0 -i list.txt -c copy "${finalPath}"`);
        }

        updateJob({ status: 'completed', progress: 100, downloadUrl: `/outputs/${finalFilename}` });
        setTimeout(() => fs.remove(workDir).catch(() => {}), 600000);
    } catch (err) {
        updateJob({ status: 'failed', error: err.message });
        fs.remove(workDir).catch(() => {});
    }
});

app.get('/status/:jobId', (req, res) => {
    const job = jobs.get(req.params.jobId);
    if (!job) return res.status(404).json({ error: 'Job not found' });
    res.json(job);
});

app.listen(PORT, '0.0.0.0', () => console.log(`Perfect Sync Beast Mode on ${PORT}`));
